{"version":3,"sources":["../../src/flashtestations/types/index.ts","../../src/flashtestations/config/chains.ts","../../src/flashtestations/types/validation.ts","../../src/flashtestations/crypto/workload.ts","../../src/flashtestations/rpc/abi.ts","../../src/flashtestations/rpc/client.ts","../../src/flashtestations/verification/service.ts"],"names":["keccak256","createPublicClient","http","parseEventLogs"],"mappings":"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","file":"index.cjs","sourcesContent":["export type WorkloadMetadata = {\n  /** workload ID of the TEE workload*/\n  workloadId: string;\n  /** Commit hash of the TEE workload source code */\n  commitHash: string;\n  /** Address of the block builder, optional */\n  builderAddress: string;\n  /** Version of the flashtestation protocol, optional */\n  version: number;\n  /** Source locators (e.g., GitHub URLs) for the workload source code, optional for backwards compatibility */\n  sourceLocators: string[];\n}\n\n/**\n * Result of flashtestation verification\n */\nexport type VerificationResult = | {\n  /** Block was built by the expected TEE workload */\n  isBuiltByExpectedTee: true;\n  blockExplorerLink: string | null;\n  workloadMetadata: WorkloadMetadata;\n}\n  | {\n    /** Block was NOT built by the expected TEE workload */\n    isBuiltByExpectedTee: false;\n    blockExplorerLink: string | null;\n    workloadMetadata: WorkloadMetadata | null;\n  };\n\n/**\n * TEE workload measurement registers used for workload ID computation\n *\n * All hex values can be provided with or without the '0x' prefix.\n *\n * Example:\n * const registers: WorkloadMeasurementRegisters = {\n    tdattributes: '0x0000000000000000',\n    xfam: '0xe700060000000000',\n    mrtd: [\"202c7d38558f7cfa086feca5a23d62fa071cceb0bd55dbd06eeb4cebbd3c204c209f5551914d41ce433fb7fd67cc7136\",\n      \"3c372ef16cb892bffd91163b8b92322abee6be34473b845bc63075072c2c0d5ba805f314afaddade64437f50018cfbd5\"],\n    mrconfigid: '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n    rtmr0: [\"6da49936a0649f6970be5df8bf7ba0d2efb66a96216c11cc65ac348432a07cfaab037b173e22c54d3f10d59327e7fbc9\",\n      \"f5cea78565e130d0e2e93429f20d269fa60aaa6bee68dd27afec0f85e3ccb885f4681ba9885b06a2ae8d202f356785a9\"],\n    rtmr1: 'c6ab9b2d76aefcfc56d41774ecf42670cbd77505b5c3f2bf77b3ff02fe5e486d476fa1332632412482d969449ed1ddb8',\n    rtmr2: '4dfecccb8027b27f4521fa8ec751362d4f2ab351aad6f0977eea49844470f3cdfcfb7e9f73159b27224111280caabbfb',\n    rtmr3: '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n  }\n */\nexport interface WorkloadMeasurementRegisters {\n  /** TD attributes (8 bytes hex) */\n  tdattributes: string;\n  /** xfam (8 bytes hex) */\n  xfam: string;\n  /** MRTD - Measurement of the TD (48 bytes hex)\n   * It can also be an array of 48 byte hex strings. We do this as a workaround for the\n   * following problem: the mrtd value on GCP's TEE's is not 100% reproducible from the\n   * VM image alone. There are some opaque components of the VM image build process that are\n   * firmware-version-dependent. To account for this, we allow multiple mrtd values as input,\n   * and when verifying measurement registers against a given workload ID, we check if any of the\n   * provided mrtd values result in a matching workload ID\n   */\n  mrtd: string | string[];\n  /** MR Config ID - VMM configuration (48 bytes hex) */\n  mrconfigid: string;\n  /** Runtime Measurement Register 0 (48 bytes hex)\n   * It can also be an array of 48 byte hex strings. We do this as a workaround for the\n   * following problem: the rtmr0 value on GCP's TEE's is not 100% reproducible from the\n   * VM image alone. There are some opaque components of the VM image build process that are\n   * firmware-version-dependent. To account for this, we allow multiple rtmr0 values as input,\n   * and when verifying measurement registers against a given workload ID, we check if any of the\n   * provided rtmr0 values result in a matching workload ID\n   */\n  rtmr0: string | string[];\n  /** Runtime Measurement Register 1 (48 bytes hex) */\n  rtmr1: string;\n  /** Runtime Measurement Register 2 (48 bytes hex) */\n  rtmr2: string;\n  /** Runtime Measurement Register 3 (48 bytes hex) */\n  rtmr3: string;\n}\n\n/**\n * TEE workload measurement registers with single values only (no arrays).\n * This type is used for workload ID computation where only one concrete set\n * of register values can be processed at a time.\n *\n * Use this type when you need to compute a single workload ID.\n * Use `WorkloadMeasurementRegisters` when accepting input that may contain\n * multiple possible values for mrtd and rtmr0.\n */\nexport interface SingularWorkloadMeasurementRegisters {\n  /** TD attributes (8 bytes hex) */\n  tdattributes: string;\n  /** xfam (8 bytes hex) */\n  xfam: string;\n  /** MRTD - Measurement of the TD (48 bytes hex) - single value only */\n  mrtd: string;\n  /** MR Config ID - VMM configuration (48 bytes hex) */\n  mrconfigid: string;\n  /** Runtime Measurement Register 0 (48 bytes hex) - single value only */\n  rtmr0: string;\n  /** Runtime Measurement Register 1 (48 bytes hex) */\n  rtmr1: string;\n  /** Runtime Measurement Register 2 (48 bytes hex) */\n  rtmr2: string;\n  /** Runtime Measurement Register 3 (48 bytes hex) */\n  rtmr3: string;\n}\n\n/**\n * Parsed flashtestation event from BlockBuilderProofVerified\n */\nexport interface FlashtestationEvent {\n  /** Address of the block builder */\n  caller: string;\n  /** Hash indentifier for the workload (bytes32 hex) */\n  workloadId: string;\n  /** Version of the flashtestation protocol */\n  version: number;\n  /** Hash of the block content (i.e. all of the block's transactions, except the flashtestation transaction itself) (bytes32 hex) */\n  blockContentHash: string;\n  /** git commit ID of the code used to reproducibly build the workload (string) */\n  commitHash: string;\n  /** Source locators (e.g., GitHub URLs) for the workload source code */\n  sourceLocators: string[];\n}\n\n/**\n * Chain configuration for multi-chain support\n */\nexport interface ChainConfig {\n  /** Chain ID */\n  chainId: number;\n  /** Human readable chain name */\n  name: string;\n  /** CLI-friendly slug for --chain argument (e.g., 'unichain-mainnet') */\n  slug: string;\n  /** BlockBuilderPolicy contract address */\n  contractAddress: string;\n  /** Default RPC URL for this chain */\n  defaultRpcUrl: string;\n  /** Block explorer base URL */\n  blockExplorerUrl: string;\n}\n\n/**\n * Minimal configuration options for the JSON-RPC client to interact with the blockchain\n */\nexport interface ClientConfig {\n  /** Chain ID to network */\n  chainId: number;\n  /** Optional custom RPC URL (overrides default) */\n  rpcUrl?: string;\n}\n\n/**\n * Block parameter for identifying blocks\n */\nexport type BlockParameter =\n  | 'earliest'\n  | 'latest'\n  | 'safe'\n  | 'finalized'\n  | 'pending'\n  | string // hex block number or block hash\n  | number // decimal block number\n  | bigint; // bigint block number\n\n/**\n * Custom error classes for specific error scenarios\n */\nexport class NetworkError extends Error {\n  constructor(message: string, public cause?: Error) {\n    super(message);\n    this.name = 'NetworkError';\n    // Maintains proper prototype chain for instanceof checks\n    Object.setPrototypeOf(this, NetworkError.prototype);\n  }\n}\n\nexport class BlockNotFoundError extends Error {\n  constructor(public blockParameter: BlockParameter) {\n    super(`Block not found: ${blockParameter}`);\n    this.name = 'BlockNotFoundError';\n    // Maintains proper prototype chain for instanceof checks\n    Object.setPrototypeOf(this, BlockNotFoundError.prototype);\n  }\n}\n\nexport class ValidationError extends Error {\n  constructor(message: string, public field?: string) {\n    super(message);\n    this.name = 'ValidationError';\n    // Maintains proper prototype chain for instanceof checks\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n\nexport class ChainNotSupportedError extends Error {\n  constructor(public chainId: number, public supportedChains: number[]) {\n    super(\n      `Chain ${chainId} not supported. Supported chains: ${supportedChains.join(\n        ', '\n      )}`\n    );\n    this.name = 'ChainNotSupportedError';\n    // Maintains proper prototype chain for instanceof checks\n    Object.setPrototypeOf(this, ChainNotSupportedError.prototype);\n  }\n}\n","import { ChainConfig, ChainNotSupportedError } from '../types/index';\n\n/**\n * Chain configuration for supported chains\n *\n * To add a new chain, simply add a new entry here with a unique slug.\n * The slug will be available as a CLI argument: --chain <slug>\n */\nexport const CHAIN_CONFIGS: Record<number, ChainConfig> = {\n  // Unichain Mainnet\n  130: {\n    chainId: 130,\n    name: 'Unichain Mainnet',\n    slug: 'unichain-mainnet',\n    contractAddress: '0xd44f9d1331659F417a3E22C9e29529D498B66A29',\n    defaultRpcUrl: process.env.RPC_URL || 'https://mainnet.unichain.org',\n    blockExplorerUrl: 'https://uniscan.xyz',\n  },\n\n  // Unichain Sepolia (Testnet)\n  1301: {\n    chainId: 1301,\n    name: 'Unichain Sepolia',\n    slug: 'unichain-sepolia',\n    contractAddress: '0x3b03b3caabd49ca12de9eba46a6a2950700b1db4',\n    defaultRpcUrl: process.env.RPC_URL || 'https://sepolia.unichain.org',\n    blockExplorerUrl: 'https://sepolia.uniscan.xyz',\n  },\n\n  // Unichain Alphanet (Testnet)\n  22444422: {\n    chainId: 22444422,\n    name: 'Unichain Alphanet',\n    slug: 'unichain-alphanet',\n    contractAddress: '0x8d0e3f57052f33CEF1e6BE98B65aad1794dc95a5',\n    defaultRpcUrl: process.env.RPC_URL || '', // note, we don't include the RPC URL for alphanet because Unichain doesn't want to expose it to the public\n    blockExplorerUrl: '',\n  },\n\n  // Unichain Experimental (Testnet)\n  420120005: {\n    chainId: 420120005,\n    name: 'Unichain Experimental',\n    slug: 'unichain-experimental',\n    contractAddress: '0x80dcdE10eE31E0A32B8944b39e8AE21d47984b4e',\n    defaultRpcUrl: process.env.RPC_URL || '', // note, we don't include the RPC URL for experimental because Unichain doesn't want to expose it to the public\n    blockExplorerUrl: '',\n  },\n};\n\n/**\n * Get the contract address for a given chain ID\n * @param chainId - The chain ID\n * @returns The BlockBuilderPolicy contract address\n * @throws ChainNotSupportedError if chain is not supported\n */\nexport function getContractAddress(chainId: number): string {\n  const config = CHAIN_CONFIGS[chainId];\n  if (!config) {\n    throw new ChainNotSupportedError(chainId, getSupportedChains());\n  }\n  return config.contractAddress;\n}\n\n/**\n * Get the RPC URL for a given chain ID\n * @param chainId - The chain ID\n * @returns The RPC URL for the chain\n * @throws ChainNotSupportedError if chain is not supported\n */\nexport function getRpcUrl(chainId: number): string {\n  const config = CHAIN_CONFIGS[chainId];\n  if (!config) {\n    throw new ChainNotSupportedError(chainId, getSupportedChains());\n  }\n  return config.defaultRpcUrl;\n}\n\n/**\n * Get the block explorer URL for a given chain ID\n * @param chainId - The chain ID\n * @returns The block explorer base URL for the chain\n * @throws ChainNotSupportedError if chain is not supported\n */\nexport function getBlockExplorerUrl(chainId: number): string {\n  const config = CHAIN_CONFIGS[chainId];\n  if (!config) {\n    throw new ChainNotSupportedError(chainId, getSupportedChains());\n  }\n  return config.blockExplorerUrl;\n}\n\n/**\n * Get the chain configuration for a given chain ID\n * @param chainId - The chain ID\n * @returns The complete chain configuration\n * @throws ChainNotSupportedError if chain is not supported\n */\nexport function getChainConfig(chainId: number): ChainConfig {\n  const config = CHAIN_CONFIGS[chainId];\n  if (!config) {\n    throw new ChainNotSupportedError(chainId, getSupportedChains());\n  }\n  return config;\n}\n\n/**\n * Get list of all supported chain IDs\n * @returns Array of supported chain IDs\n */\nexport function getSupportedChains(): number[] {\n  return Object.keys(CHAIN_CONFIGS).map(Number);\n}\n\n/**\n * Check if a chain ID is supported\n * @param chainId - The chain ID to check\n * @returns True if the chain is supported, false otherwise\n */\nexport function isChainSupported(chainId: number): boolean {\n  return chainId in CHAIN_CONFIGS;\n}\n\n/**\n * Get chain configuration by slug\n * @param slug - The chain slug (e.g., 'unichain-mainnet')\n * @returns The chain configuration, or undefined if not found\n */\nexport function getChainBySlug(slug: string): ChainConfig | undefined {\n  return Object.values(CHAIN_CONFIGS).find((config) => config.slug === slug);\n}\n\n/**\n * Get list of all supported chain slugs\n * @returns Array of supported chain slugs\n */\nexport function getSupportedChainSlugs(): string[] {\n  return Object.values(CHAIN_CONFIGS).map((config) => config.slug);\n}\n\n/**\n * Check if a chain slug is valid\n * @param slug - The chain slug to check\n * @returns True if the slug is valid, false otherwise\n */\nexport function isValidChainSlug(slug: string): boolean {\n  return Object.values(CHAIN_CONFIGS).some((config) => config.slug === slug);\n}\n\n/**\n * Get the default chain slug\n * @returns The default chain slug (unichain-mainnet)\n */\nexport function getDefaultChainSlug(): string {\n  return 'unichain-mainnet';\n}\n","import type { WorkloadMeasurementRegisters, SingularWorkloadMeasurementRegisters } from './index';\nimport { ValidationError } from './index';\n\n/**\n * Validates if a string is a valid hex string with optional 0x prefix\n */\nexport function isValidHex(value: string, expectedLength?: number): boolean {\n  const cleanHex = value.startsWith('0x') ? value.slice(2) : value;\n  const hexRegex = /^[0-9a-fA-F]+$/;\n\n  if (!hexRegex.test(cleanHex)) {\n    return false;\n  }\n\n  if (expectedLength && cleanHex.length !== expectedLength) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Validates hex string and throws ValidationError if invalid\n */\nfunction validateHex(\n  value: string,\n  expectedLength: number,\n  fieldName: string\n): void {\n  if (!isValidHex(value, expectedLength)) {\n    const cleanHex = value.startsWith('0x') ? value.slice(2) : value;\n    throw new ValidationError(\n      `Invalid ${fieldName}: expected ${expectedLength} hex characters, got ${cleanHex.length}`,\n      fieldName\n    );\n  }\n}\n\n/**\n * Validates WorkloadMeasurementRegisters structure and field formats\n * Supports arrays for mrtd and rtmr0 fields\n */\nexport function validateWorkloadMeasurementRegisters(\n  registers: WorkloadMeasurementRegisters\n): void {\n  // Validate tdattributes (8 bytes = 16 hex chars)\n  validateHex(registers.tdattributes, 16, 'tdattributes');\n\n  // Validate xfam (8 bytes = 16 hex chars)\n  validateHex(registers.xfam, 16, 'xfam');\n\n  // Validate mrtd (48 bytes = 96 hex chars) - can be single value or array\n  if (Array.isArray(registers.mrtd)) {\n    if (registers.mrtd.length === 0) {\n      throw new ValidationError('mrtd array cannot be empty', 'mrtd');\n    }\n    registers.mrtd.forEach((value, index) => {\n      validateHex(value, 96, `mrtd[${index}]`);\n    });\n  } else {\n    validateHex(registers.mrtd, 96, 'mrtd');\n  }\n\n  // Validate mrconfigid (48 bytes = 96 hex chars)\n  validateHex(registers.mrconfigid, 96, 'mrconfigid');\n\n  // Validate rtmr0 (48 bytes = 96 hex chars) - can be single value or array\n  if (Array.isArray(registers.rtmr0)) {\n    if (registers.rtmr0.length === 0) {\n      throw new ValidationError('rtmr0 array cannot be empty', 'rtmr0');\n    }\n    registers.rtmr0.forEach((value, index) => {\n      validateHex(value, 96, `rtmr0[${index}]`);\n    });\n  } else {\n    validateHex(registers.rtmr0, 96, 'rtmr0');\n  }\n\n  // Validate runtime measurement registers (48 bytes = 96 hex chars each)\n  validateHex(registers.rtmr1, 96, 'rtmr1');\n  validateHex(registers.rtmr2, 96, 'rtmr2');\n  validateHex(registers.rtmr3, 96, 'rtmr3');\n}\n\n/**\n * Validates that all fields in SingularWorkloadMeasurementRegisters are single values\n * This is stricter than validateWorkloadMeasurementRegisters - no arrays allowed\n *\n * @throws {ValidationError} If mrtd or rtmr0 are arrays, or if any field is invalid\n */\nexport function validateSingularWorkloadMeasurementRegisters(\n  registers: SingularWorkloadMeasurementRegisters\n): void {\n  // Runtime check that mrtd and rtmr0 are NOT arrays (type guard)\n  if (Array.isArray(registers.mrtd)) {\n    throw new ValidationError('mrtd must be a single value, not an array', 'mrtd');\n  }\n  if (Array.isArray(registers.rtmr0)) {\n    throw new ValidationError('rtmr0 must be a single value, not an array', 'rtmr0');\n  }\n\n  // Then validate all fields using the standard validator\n  // This works because SingularWorkloadMeasurementRegisters is structurally compatible\n  // with WorkloadMeasurementRegisters when mrtd and rtmr0 are single values\n  validateWorkloadMeasurementRegisters(registers as WorkloadMeasurementRegisters);\n}\n\n/**\n * Normalizes hex string by removing 0x prefix and converting to lowercase\n */\nexport function normalizeHex(value: string): string {\n  const cleanHex = value.startsWith('0x') ? value.slice(2) : value;\n  return cleanHex.toLowerCase();\n}\n\n","import { keccak256 } from 'viem/utils';\n\nimport type { WorkloadMeasurementRegisters, SingularWorkloadMeasurementRegisters } from '../types/index';\nimport {\n  validateWorkloadMeasurementRegisters,\n  validateSingularWorkloadMeasurementRegisters,\n} from '../types/validation';\n\n/**\n * Converts a hex string to a Uint8Array\n * This is a helper function to convert a hex string to a Uint8Array\n * Accepts both 0x-prefixed and non-prefixed hex strings\n * @example:\n * - '0x123456789abcde' -> Uint8Array([0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde])\n * - '123456789abcde' -> Uint8Array([0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde])\n * @param hex - The hex string to convert (with or without 0x prefix)\n * @returns The Uint8Array\n * @throws If the hex string is invalid\n *\n */\nfunction hexToBytes(hex: string): Uint8Array {\n  const unprefixedHex = hex.startsWith('0x') ? hex.slice(2) : hex;\n  if (unprefixedHex.length % 2 !== 0) throw new Error(\"Invalid hex string\");\n  return Uint8Array.from(unprefixedHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\n}\n\n/**\n * Concatenates multiple Uint8Arrays\n * @example:\n * - concatBytes(Uint8Array([0x12, 0x34]), Uint8Array([0x56, 0x78]), Uint8Array([0x9a, 0xbc])) -> Uint8Array([0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc])\n * @param arrays - The Uint8Arrays to concatenate\n * @returns The result of the concatenation\n */\nfunction concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\n/**\n * Computes workload ID from TEE measurement registers\n * Formula: keccak256(mrTd + rtMr0 + rtMr1 + rtMr2 + rtMr3 + mrConfigId + (xFAM ^ expectedXfamBits) + (tdAttributes & ~ignoredTdAttributesBitmask))\n * This is copied from the Solidity implementation of the workload ID computation at:\n * https://github.com/flashbots/flashtestations/blob/38594f37b5f6d1b1f5f6ad4203a4770c10f72a22/src/BlockBuilderPolicy.sol#L208\n *\n * @param registers - Singular workload measurement registers\n * @returns The computed workload ID as a hex string\n *\n * @remarks\n * This function only accepts singular registers. If you have registers with multiple\n * possible values (arrays), use `computeAllWorkloadIds()` or `expandToSingularRegisters()` first.\n */\nexport function computeWorkloadId(registers: SingularWorkloadMeasurementRegisters): string {\n  // Validate input registers (ensures no arrays)\n  validateSingularWorkloadMeasurementRegisters(registers);\n\n  // Convert hex strings to Uint8Arrays for bitwise operations\n  const mrTd = hexToBytes(registers.mrtd);\n  const rtMr0 = hexToBytes(registers.rtmr0);\n  const rtMr1 = hexToBytes(registers.rtmr1);\n  const rtMr2 = hexToBytes(registers.rtmr2);\n  const rtMr3 = hexToBytes(registers.rtmr3);\n  const mrConfigId = hexToBytes(registers.mrconfigid);\n  const xFAM = hexToBytes(registers.xfam);\n  const tdAttributes = hexToBytes(registers.tdattributes);\n\n  // Concatenate all components and hash\n  return keccak256(\n    concatBytes(mrTd, rtMr0, rtMr1, rtMr2, rtMr3, mrConfigId, xFAM, tdAttributes)\n  );\n}\n\n/**\n * Expands WorkloadMeasurementRegisters with array fields into all possible\n * singular register combinations (cartesian product of mrTd and rtMr0 values)\n *\n * @param registers - Flexible registers that may contain arrays\n * @returns Array of all possible singular register combinations\n *\n * @example\n * ```typescript\n * const input = {\n *   // ... other fields\n *   mrtd: ['0xaaa...', '0xbbb...'],\n *   rtmr0: ['0xccc...', '0xddd...']\n * };\n * // Returns 4 combinations: (aaa,ccc), (aaa,ddd), (bbb,ccc), (bbb,ddd)\n * const singularRegisters = expandToSingularRegisters(input);\n * ```\n */\nexport function expandToSingularRegisters(\n  registers: WorkloadMeasurementRegisters\n): SingularWorkloadMeasurementRegisters[] {\n  // Validate input first\n  validateWorkloadMeasurementRegisters(registers);\n\n  // Normalize mrtd and rtmr0 to arrays\n  const mrTdValues = Array.isArray(registers.mrtd) ? registers.mrtd : [registers.mrtd];\n  const rtMr0Values = Array.isArray(registers.rtmr0) ? registers.rtmr0 : [registers.rtmr0];\n\n  // Generate cartesian product\n  const result: SingularWorkloadMeasurementRegisters[] = [];\n  for (const mrtd of mrTdValues) {\n    for (const rtmr0 of rtMr0Values) {\n      result.push({\n        tdattributes: registers.tdattributes,\n        xfam: registers.xfam,\n        mrtd: mrtd,\n        mrconfigid: registers.mrconfigid,\n        rtmr0: rtmr0,\n        rtmr1: registers.rtmr1,\n        rtmr2: registers.rtmr2,\n        rtmr3: registers.rtmr3,\n      });\n    }\n  }\n\n  return result;\n}\n\n/**\n * Computes all possible workload IDs for the given registers.\n * If registers contain arrays, computes the ID for each combination.\n *\n * @param registers - Flexible registers that may contain arrays\n * @returns Array of all possible workload IDs\n *\n * @example\n * ```typescript\n * const registers = {\n *   // ... other fields\n *   mrtd: ['0xaaa...', '0xbbb...'],\n *   rtmr0: ['0xccc...', '0xddd...']\n * };\n * // Returns 4 workload IDs, one for each combination\n * const ids = computeAllWorkloadIds(registers);\n * ```\n */\nexport function computeAllWorkloadIds(\n  registers: WorkloadMeasurementRegisters\n): string[] {\n  const singularRegisters = expandToSingularRegisters(registers);\n  return singularRegisters.map(singular => computeWorkloadId(singular));\n}\n\n/**\n * Checks if any of the possible workload IDs from the given registers\n * match the expected workload ID.\n *\n * @param registers - Flexible registers that may contain arrays\n * @param expectedWorkloadId - The workload ID to match against\n * @returns true if any combination matches the expected ID\n *\n * @example\n * ```typescript\n * const registers = {\n *   // ... other fields\n *   mrtd: ['0xaaa...', '0xbbb...'],\n *   rtmr0: ['0xccc...', '0xddd...']\n * };\n * // Returns true if any of the 4 possible IDs matches\n * const matches = matchesAnyWorkloadId(registers, expectedId);\n * ```\n */\nexport function matchesAnyWorkloadId(\n  registers: WorkloadMeasurementRegisters,\n  expectedWorkloadId: string\n): boolean {\n  const allIds = computeAllWorkloadIds(registers);\n  return allIds.includes(expectedWorkloadId);\n}\n","/**\n * ABI definition for Flashtestation contract events\n */\nexport const flashtestationAbi = [\n  {\n    type: 'event',\n    name: 'BlockBuilderProofVerified',\n    inputs: [\n      {\n        indexed: false,\n        name: 'caller',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        name: 'workloadId',\n        type: 'bytes32',\n      },\n      {\n        indexed: false,\n        name: 'version',\n        type: 'uint8',\n      },\n      {\n        indexed: false,\n        name: 'blockContentHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: false,\n        name: 'commitHash',\n        type: 'string',\n      },\n    ],\n  },\n  {\n    type: 'function',\n    name: 'getWorkloadMetadata',\n    inputs: [\n      {\n        name: 'workloadId',\n        type: 'bytes32',\n        internalType: 'WorkloadId',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'tuple',\n        internalType: 'struct IBlockBuilderPolicy.WorkloadMetadata',\n        components: [\n          {\n            name: 'commitHash',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'sourceLocators',\n            type: 'string[]',\n            internalType: 'string[]',\n          },\n        ],\n      },\n    ],\n    stateMutability: 'view',\n  },\n] as const;\n","import {\n  createPublicClient,\n  http,\n  type Block,\n  type TransactionReceipt,\n  type BlockTag,\n  type Chain,\n  PublicClient,\n  parseEventLogs,\n} from 'viem';\n\nimport { getRpcUrl, getChainConfig, getContractAddress } from '../config/chains';\nimport {\n  BlockParameter,\n  NetworkError,\n  BlockNotFoundError,\n  FlashtestationEvent,\n} from '../types';\n\nimport { flashtestationAbi } from './abi';\n\n/**\n * Configuration options for the RPC client\n */\nexport interface RpcClientConfig {\n  /** Chain ID to connect to */\n  chainId: number;\n  /** Optional custom RPC URL (overrides default) */\n  rpcUrl?: string;\n  /** Number of retry attempts for failed requests (default: 3) */\n  maxRetries?: number;\n  /** Initial retry delay in milliseconds (default: 1000) */\n  initialRetryDelay?: number;\n}\n\ntype WorkloadMetadata = {\n  commitHash: string;\n  sourceLocators: string[];\n}\n\n/**\n * Cache of RPC clients keyed by chain ID and RPC URL\n */\nconst clientCache = new Map<string, PublicClient>();\n\n/**\n * Get a cached client key\n */\nfunction getClientKey(chainId: number, rpcUrl: string): string {\n  return `${chainId}:${rpcUrl}`;\n}\n\n/**\n * Create a viem Chain object from chain ID\n */\nfunction createChainFromId(chainId: number): Chain {\n  const config = getChainConfig(chainId);\n  return {\n    id: chainId,\n    name: config.name,\n    nativeCurrency: {\n      name: 'Ether',\n      symbol: 'ETH',\n      decimals: 18,\n    },\n    rpcUrls: {\n      default: {\n        http: [config.defaultRpcUrl],\n      },\n    },\n    blockExplorers: {\n      default: {\n        name: 'Explorer',\n        url: config.blockExplorerUrl,\n      },\n    },\n  } as const satisfies Chain;\n}\n\n/**\n * Convert BlockParameter to viem getBlock argument\n * Distinguishes between block hashes (66 char hex) and block numbers\n */\nfunction toViemBlockParameter(\n  blockParam: BlockParameter\n):\n  | { blockTag: BlockTag }\n  | { blockNumber: bigint }\n  | { blockHash: `0x${string}` } {\n  // Handle block tags\n  if (\n    blockParam === 'earliest' ||\n    blockParam === 'latest' ||\n    blockParam === 'safe' ||\n    blockParam === 'finalized' ||\n    blockParam === 'pending'\n  ) {\n    return { blockTag: blockParam as BlockTag };\n  }\n\n  // Handle bigint\n  if (typeof blockParam === 'bigint') {\n    return { blockNumber: blockParam };\n  }\n\n  // Handle hex string\n  if (typeof blockParam === 'string') {\n    if (blockParam.startsWith('0x')) {\n      // Block hashes are 32 bytes = 66 characters (including 0x)\n      if (blockParam.length === 66) {\n        return { blockHash: blockParam as `0x${string}` };\n      }\n      // Otherwise it's a hex block number\n      return { blockNumber: BigInt(blockParam) };\n    }\n    // Convert decimal string to bigint\n    return { blockNumber: BigInt(blockParam) };\n  }\n\n  // Handle number\n  return { blockNumber: BigInt(blockParam) };\n}\n\n/**\n * Retry a function with exponential backoff\n */\nasync function retry<T>(\n  fn: () => Promise<T>,\n  maxRetries: number,\n  initialDelay: number\n): Promise<T> {\n  let lastError: Error | undefined;\n  let delay = initialDelay;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n\n      // Don't retry BlockNotFoundError - it's a permanent error\n      if (lastError instanceof BlockNotFoundError) {\n        throw lastError;\n      }\n\n      // Don't retry on the last attempt\n      if (attempt === maxRetries) {\n        break;\n      }\n\n      // Wait before retrying with exponential backoff\n      await new Promise(resolve => setTimeout(resolve, delay));\n      delay *= 2;\n    }\n  }\n\n  throw new NetworkError(\n    `Failed after ${maxRetries + 1} attempts: ${lastError?.message}`,\n    lastError\n  );\n}\n\n/**\n * RPC Client for blockchain interactions with retry logic and connection reuse\n */\nexport class RpcClient {\n  private client: PublicClient;\n  private config: Required<RpcClientConfig>;\n\n  /**\n   * Create a new RPC client\n   * @param config - Configuration for the RPC client\n   */\n  constructor(config: RpcClientConfig) {\n    this.config = {\n      chainId: config.chainId,\n      rpcUrl: config.rpcUrl || getRpcUrl(config.chainId),\n      maxRetries: config.maxRetries ?? 3,\n      initialRetryDelay: config.initialRetryDelay ?? 1000,\n    };\n  \n    // this will only execute for alphanet and experimental because we don't include the RPC URL in the ChainConfig\n    if (!this.config.rpcUrl) {\n      throw new Error('rpcUrl argument is required in RpcClient constructor, but was not provided');\n    }\n\n    // Check for cached client\n    const cacheKey = getClientKey(this.config.chainId, this.config.rpcUrl);\n    const cachedClient = clientCache.get(cacheKey);\n\n    if (cachedClient) {\n      this.client = cachedClient;\n    } else {\n      // Create new client with chain configuration\n      const chain = createChainFromId(this.config.chainId);\n      this.client = createPublicClient({\n        chain,\n        transport: http(this.config.rpcUrl, {\n          timeout: 30_000, // 30 second timeout\n        }),\n      });\n\n      // Cache the client for reuse\n      clientCache.set(cacheKey, this.client);\n    }\n  }\n\n  /**\n   * Get a block by block parameter\n   * @param blockParameter - Block identifier (tag, number, hash, or hex)\n   * @returns Block data\n   * @throws BlockNotFoundError if block doesn't exist\n   * @throws NetworkError if RPC connection fails\n   */\n  async getBlock(blockParameter: BlockParameter): Promise<Block> {\n    return retry(\n      async () => {\n        try {\n          const viemBlockParam = toViemBlockParameter(blockParameter);\n          const block = await this.client.getBlock(viemBlockParam);\n\n          if (!block) {\n            throw new BlockNotFoundError(blockParameter);\n          }\n\n          return block;\n        } catch (error) {\n          // Don't retry BlockNotFoundError - re-throw immediately\n          if (error instanceof BlockNotFoundError) {\n            throw error;\n          }\n\n          // Wrap viem errors in our custom error types\n          const err = error as Error;\n          if (\n            err.message?.includes('not found') ||\n            err.message?.includes('does not exist')\n          ) {\n            throw new BlockNotFoundError(blockParameter);\n          }\n          throw error;\n        }\n      },\n      this.config.maxRetries,\n      this.config.initialRetryDelay\n    );\n  }\n\n  /**\n   * Get a transaction receipt by transaction hash\n   * @param txHash - Transaction hash\n   * @returns Transaction receipt\n   * @throws NetworkError if RPC connection fails\n   */\n  async getTransactionReceipt(txHash: string): Promise<TransactionReceipt> {\n    return retry(\n      async () => {\n        const receipt = await this.client.getTransactionReceipt({\n          hash: txHash as `0x${string}`,\n        });\n\n        if (!receipt) {\n          throw new Error(`Transaction receipt not found: ${txHash}`);\n        }\n\n        return receipt;\n      },\n      this.config.maxRetries,\n      this.config.initialRetryDelay\n    );\n  }\n\n  /**\n   * Get source locators for a workload ID from the BlockBuilderPolicy contract\n   * @param workloadId - The workload ID (bytes32 hex string)\n   * @returns Array of source locator strings\n   * @throws NetworkError if RPC connection fails\n   */\n  async getSourceLocators(workloadId: `0x${string}`): Promise<string[]> {\n    return retry(\n      async () => {\n        const contractAddress = getContractAddress(this.config.chainId);\n\n        const result = await this.client.readContract({\n          address: contractAddress as `0x${string}`,\n          abi: flashtestationAbi,\n          functionName: 'getWorkloadMetadata',\n          args: [workloadId],\n        });\n\n        // result is an object with commitHash and sourceLocators\n        // We only need the sourceLocators array\n        return (result as WorkloadMetadata).sourceLocators as string[];\n      },\n      this.config.maxRetries,\n      this.config.initialRetryDelay\n    );\n  }\n\n  /**\n   * Get a flashtestation event by transaction hash\n   * Checks if the transaction emitted a BlockBuilderProofVerified event\n   * @param txHash - Transaction hash\n   * @returns FlashtestationEvent data if it's a flashtestation tx, null otherwise\n   * @throws NetworkError if RPC connection fails\n   */\n  async getFlashtestationEvent(\n    blockParameter: BlockParameter = 'latest'\n  ): Promise<FlashtestationEvent | null> {\n    return retry(\n      async () => {\n        // First, get the transaction hash from the block\n        const block = await this.getBlock(blockParameter);\n        if (!block.transactions || block.transactions.length === 0) {\n          return null;\n        }\n        const txHash = block.transactions[block.transactions.length - 1] as `0x${string}`;\n        \n        // Then, get the transaction receipt to parse the logs for the BlockBuilderProofVerified event\n        const receipt = await this.client.getTransactionReceipt({\n          hash: txHash,\n        });\n\n        if (!receipt) {\n          return null;\n        }\n\n        // Parse the logs from the receipt to find BlockBuilderProofVerified events\n        const parsedLogs = parseEventLogs({\n          abi: flashtestationAbi,\n          eventName: 'BlockBuilderProofVerified',\n          logs: receipt.logs,\n        });\n\n        // If we found the BlockBuilderProofVerified event, parse and return it\n        if (parsedLogs.length > 0) {\n          if (parsedLogs.length !== 1) {\n            throw new Error('Expected exactly one BlockBuilderProofVerified event');\n          }\n          const log = parsedLogs[0];\n          const args = log.args as {\n            caller: `0x${string}`;\n            workloadId: `0x${string}`;\n            version: number;\n            blockContentHash: `0x${string}`;\n            commitHash: string;\n          };\n\n          // Fetch source locators from contract\n          const sourceLocators = await this.getSourceLocators(args.workloadId);\n\n          return {\n            caller: args.caller,\n            workloadId: args.workloadId,\n            version: args.version,\n            blockContentHash: args.blockContentHash,\n            commitHash: args.commitHash,\n            sourceLocators,\n          };\n        }\n\n        return null;\n      },\n      this.config.maxRetries,\n      this.config.initialRetryDelay\n    );\n  }\n\n  /**\n   * Get the underlying viem PublicClient\n   * @returns The viem PublicClient instance\n   */\n  getClient(): PublicClient {\n    return this.client;\n  }\n\n  /**\n   * Clear the client cache (useful for testing)\n   */\n  static clearCache(): void {\n    clientCache.clear();\n  }\n}\n\n/**\n * Create an RPC client with the given configuration\n * @param config - Configuration for the RPC client\n * @returns A new RpcClient instance\n */\nexport function createRpcClient(config: RpcClientConfig): RpcClient {\n  return new RpcClient(config);\n}\n","import { getBlockExplorerUrl } from '../config/chains';\nimport { computeAllWorkloadIds } from '../crypto/workload';\nimport { RpcClient } from '../rpc/client';\nimport {\n  BlockParameter,\n  VerificationResult,\n  WorkloadMeasurementRegisters,\n  ClientConfig,\n  FlashtestationEvent,\n} from '../types';\n\n/**\n * Fetch the event data of the flashtestation transaction from a specific block\n *\n * This function retrieves the flashtestation event (if any) from the specified block.\n * Unlike verifyFlashtestationInBlock, this does not perform any workload verification - it\n * simply returns the raw flashtestation event data.\n *\n * @param blockParameter - Block identifier (tag, number, or hash), defaults to 'latest'\n * @param config - Configuration for chain and RPC connection\n * @returns FlashtestationEvent if the block contains a flashtestation transaction, null otherwise\n * @throws NetworkError if RPC connection fails\n * @throws BlockNotFoundError if block doesn't exist\n *\n * @example\n * // Get flashtestation event from the latest block\n * const flashtestationEvent = await getFlashtestationEvent('latest', { chainId: 1301 });\n * if (flashtestationEvent) {\n *   console.log('Workload ID:', flashtestationEvent.workloadId);\n *   console.log('Commit Hash:', flashtestationEvent.commitHash);\n * }\n *\n * @example\n * // Get flashtestation event data from a specific block number\n * const flashtestationEvent = await getFlashtestationEvent(12345, { chainId: 1301 });\n */\nexport async function getFlashtestationEvent(\n  blockParameter: BlockParameter = 'latest',\n  config: ClientConfig\n): Promise<FlashtestationEvent | null> {\n  // Create RPC client\n  const client = new RpcClient({\n    chainId: config.chainId,\n    rpcUrl: config.rpcUrl,\n  });\n\n  // Get the flashtestation transaction's event data from the block\n  return await client.getFlashtestationEvent(blockParameter);\n}\n\n/**\n * Verify if a block was built by a TEE running a specific workload\n *\n * This is the main entry point for flashtestation verification. It checks if\n * the specified block contains a flashtestation transaction whose event data matches the\n * provided workload ID or measurement registers.\n *\n * @param workloadIdOrRegisters - Either a workload ID string or measurement registers to compute the ID\n * @param blockParameter - Block identifier (tag, number, or hash)\n * @param config - Configuration for chain and RPC connection\n * @returns Verification result indicating if block was built by the specified TEE workload\n * @throws NetworkError if RPC connection fails\n * @throws BlockNotFoundError if block doesn't exist\n * @throws ValidationError if measurement registers are invalid\n *\n * @example\n * // Verify using a workload ID\n * const result = await verifyFlashtestationInBlock(\n *   '0x1234...',\n *   'latest',\n *   { chainId: 1301 }\n * );\n *\n * @example\n * // Verify using measurement registers\n * const registers = {\n *   tdattributes: '0x0000000000000000',\n *   xfam: '0x0000000000000003',\n *   mrtd: '0x1234...',\n *   mrconfigid: '0x0000...',\n *   rtmr0: '0xabcd...',\n *   rtmr1: '0xef01...',\n *   rtmr2: '0x2345...',\n *   rtmr3: '0x6789...',\n * };\n * const result = await verifyFlashtestationInBlock(\n *   registers,\n *   12345,\n *   { chainId: 1301 }\n * );\n */\nexport async function verifyFlashtestationInBlock(\n  workloadIdOrRegisters: string | WorkloadMeasurementRegisters,\n  blockParameter: BlockParameter,\n  config: ClientConfig\n): Promise<VerificationResult> {\n  // Determine if we need to compute workload ID(s) from registers\n  let workloadIds: string[];\n\n  if (typeof workloadIdOrRegisters === 'string') {\n    // Direct workload ID provided\n    workloadIds = [workloadIdOrRegisters];\n  } else {\n    // Compute all possible workload IDs from measurement registers\n    // (handles arrays in mrtd and rtmr0 fields)\n    workloadIds = computeAllWorkloadIds(workloadIdOrRegisters);\n  }\n\n  // Normalize workload IDs (ensure they have 0x prefix and are lowercase)\n  workloadIds = workloadIds.map(id => {\n    if (!id.startsWith('0x')) {\n      id = '0x' + id;\n    }\n    return id.toLowerCase();\n  });\n\n  // Create RPC client\n  const client = new RpcClient({\n    chainId: config.chainId,\n    rpcUrl: config.rpcUrl,\n  });\n\n  // Get the flashtestation event data from the block\n  const flashtestationEvent = await client.getFlashtestationEvent(blockParameter);\n\n  // If no flashtestation event data found, block was not TEE-built\n  if (!flashtestationEvent) {\n    return {\n      isBuiltByExpectedTee: false,\n      blockExplorerLink: null,\n      workloadMetadata: null,\n    };\n  }\n\n  // Get block explorer URL for this chain\n  const blockExplorerBaseUrl = getBlockExplorerUrl(config.chainId);\n\n  // Get the block to construct the explorer link\n  const block = await client.getBlock(blockParameter);\n\n  // Construct block explorer link if available\n  let blockExplorerLink: string | null = null;\n  if (blockExplorerBaseUrl) {\n    // Use block number for the explorer link\n    blockExplorerLink = `${blockExplorerBaseUrl}/block/${block.number}`;\n  }\n\n  // Normalize event workload ID for comparison\n  const eventWorkloadId = flashtestationEvent.workloadId.toLowerCase();\n\n  // Compare workload IDs - check if any of the possible IDs match\n  const workloadMatches = workloadIds.includes(eventWorkloadId);\n\n  if (!workloadMatches) {\n    // Block was built by a TEE, but not the one we're looking for\n    return {\n      isBuiltByExpectedTee: false,\n      blockExplorerLink: blockExplorerLink,\n      workloadMetadata: {\n        workloadId: flashtestationEvent.workloadId,\n        commitHash: flashtestationEvent.commitHash,\n        builderAddress: flashtestationEvent.caller,\n        version: flashtestationEvent.version,\n        sourceLocators: flashtestationEvent.sourceLocators,\n      }\n    };\n  }\n\n  // Block was built by the specified TEE workload\n  return {\n    isBuiltByExpectedTee: true,\n    blockExplorerLink: blockExplorerLink,\n    workloadMetadata: {\n      workloadId: flashtestationEvent.workloadId,\n      commitHash: flashtestationEvent.commitHash,\n      builderAddress: flashtestationEvent.caller,\n      version: flashtestationEvent.version,\n      sourceLocators: flashtestationEvent.sourceLocators,\n    }\n  };\n}\n"]}