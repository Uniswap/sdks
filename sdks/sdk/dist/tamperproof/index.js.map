{"version":3,"sources":["../../src/tamperproof/algorithms.ts","../../src/tamperproof/constants/errors.ts","../../src/tamperproof/utils/hex.ts","../../src/tamperproof/generate.ts","../../src/tamperproof/utils/webcrypto.ts","../../src/tamperproof/utils/canonicalJson.ts","../../src/tamperproof/sign.ts","../../src/tamperproof/utils/txtRecord.ts","../../src/tamperproof/verify.ts"],"names":["nodeWebcrypto"],"mappings":"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","file":"index.js","sourcesContent":["export type SigningAlgorithmConfig = {\n  name: string;\n  hash?: { name: string };\n  saltLength?: number;\n  namedCurve?: string;\n  ecdsaCoordinateLength?: number;\n};\n\nexport const SIGNING_ALGORITHM_IMPORT_PARAMS = {\n  ES256: {\n    name: \"ECDSA\",\n    namedCurve: \"P-256\",\n  } as EcKeyImportParams,\n  ES384: {\n    name: \"ECDSA\",\n    namedCurve: \"P-384\",\n  } as EcKeyImportParams,\n  ES512: {\n    name: \"ECDSA\",\n    namedCurve: \"P-521\",\n  } as EcKeyImportParams,\n  EdDSA: {\n    name: \"Ed25519\",\n  } as Algorithm,\n  PS256: {\n    name: \"RSA-PSS\",\n    hash: { name: \"SHA-256\" },\n  } as RsaHashedImportParams,\n  PS384: {\n    name: \"RSA-PSS\",\n    hash: { name: \"SHA-384\" },\n  } as RsaHashedImportParams,\n  PS512: {\n    name: \"RSA-PSS\",\n    hash: { name: \"SHA-512\" },\n  } as RsaHashedImportParams,\n  RS256: {\n    name: \"RSASSA-PKCS1-v1_5\",\n    hash: { name: \"SHA-256\" },\n  } as RsaHashedImportParams,\n  RS384: {\n    name: \"RSASSA-PKCS1-v1_5\",\n    hash: { name: \"SHA-384\" },\n  } as RsaHashedImportParams,\n  RS512: {\n    name: \"RSASSA-PKCS1-v1_5\",\n    hash: { name: \"SHA-512\" },\n  } as RsaHashedImportParams,\n};\n\nexport const SIGNING_ALGORITHM_CONFIG = {\n  ES256: {\n    name: \"ECDSA\",\n    hash: { name: \"SHA-256\" },\n    namedCurve: \"P-256\",\n    ecdsaCoordinateLength: 32,\n  },\n  ES384: {\n    name: \"ECDSA\",\n    hash: { name: \"SHA-384\" },\n    namedCurve: \"P-384\",\n    ecdsaCoordinateLength: 48,\n  },\n  ES512: {\n    name: \"ECDSA\",\n    hash: { name: \"SHA-512\" },\n    namedCurve: \"P-521\",\n    ecdsaCoordinateLength: 66,\n  },\n  EdDSA: {\n    name: \"Ed25519\",\n  },\n  PS256: {\n    name: \"RSA-PSS\",\n    hash: { name: \"SHA-256\" },\n    saltLength: 32,\n  },\n  PS384: {\n    name: \"RSA-PSS\",\n    hash: { name: \"SHA-384\" },\n    saltLength: 48,\n  },\n  PS512: {\n    name: \"RSA-PSS\",\n    hash: { name: \"SHA-512\" },\n    saltLength: 64,\n  },\n  RS256: {\n    name: \"RSASSA-PKCS1-v1_5\",\n    hash: { name: \"SHA-256\" },\n  },\n  RS384: {\n    name: \"RSASSA-PKCS1-v1_5\",\n    hash: { name: \"SHA-384\" },\n  },\n  RS512: {\n    name: \"RSASSA-PKCS1-v1_5\",\n    hash: { name: \"SHA-512\" },\n  },\n} satisfies Record<string, SigningAlgorithmConfig>;\n","export const ERROR_ALGORITHM_NOT_SUPPORTED = (alg: unknown): string =>\n  `Algorithm is not supported: ${String(alg)}`;\n\nexport const ERROR_NO_TXT_RECORDS_FOR_HOST = (host: string): string =>\n  `No TXT records found for host ${host}`;\n\nexport const ERROR_NO_TXT_WITH_PREFIX_FOR_HOST = (\n  prefix: string,\n  host: string\n): string => `No TXT record found with prefix ${prefix} for host ${host}`;\n\nexport const ERROR_MULTIPLE_TXT_WITH_PREFIX_FOR_HOST = (\n  prefix: string,\n  host: string\n): string =>\n  `Multiple TXT records found with prefix ${prefix} for host ${host}. Only one is allowed.`;\n\nexport const ERROR_TWIST_PATH_TOO_LONG = \"TWIST path too long\";\n\nexport const ERROR_MANIFEST_HTTPS_ONLY = \"Manifest must be fetched over HTTPS\";\n\nexport const ERROR_MANIFEST_FETCH_FAILED = (status: number): string =>\n  `Failed to fetch manifest: HTTP ${status}`;\n\nexport const ERROR_MANIFEST_CONTENT_TYPE =\n  \"Manifest Content-Type must be application/json\";\n\nexport const ERROR_MANIFEST_TOO_LARGE = \"Manifest too large\";\n\nexport const ERROR_PUBLIC_KEY_ID_NOT_FOUND = (id: string | number): string =>\n  `Public key with id ${id} not found`;\n\nexport const ERROR_MULTIPLE_PUBLIC_KEYS_WITH_ID = (\n  id: string | number\n): string =>\n  `Multiple public keys found with id ${id}. Key IDs must be unique.`;\n\nexport const ERROR_INVALID_TXT_RECORD_FORMAT =\n  \"Invalid TXT record format: length exceeds buffer size\";\n\nexport const ERROR_INVALID_HEX_LENGTH_EVEN =\n  \"Invalid hex string: length must be even\";\n\nexport const ERROR_INVALID_HEX_STRING = (hex: string): string =>\n  `Invalid hex string: ${hex}`;\n\nexport const ERROR_NO_BASE64_DECODER =\n  \"No base64 decoder available in this environment\";\n","import {\n  ERROR_INVALID_HEX_LENGTH_EVEN,\n  ERROR_INVALID_HEX_STRING,\n  ERROR_NO_BASE64_DECODER,\n} from \"../constants/errors.js\";\n\n/**\n * Decodes a hex string into bytes.\n *\n * - Accepts input with or without a `0x` prefix; ignores whitespace\n * - Requires even length and only [0-9a-fA-F] characters\n * - Throws on invalid length or characters\n *\n * Returns a `Uint8Array` of decoded bytes.\n */\nexport function fromHex(hex: string): Uint8Array {\n  const cleanHex = hex.replace(/^0x/i, \"\").replace(/\\s/g, \"\");\n  if (cleanHex.length % 2 !== 0) {\n    throw new Error(ERROR_INVALID_HEX_LENGTH_EVEN);\n  }\n  if (!/^[0-9a-fA-F]*$/.test(cleanHex)) {\n    throw new Error(ERROR_INVALID_HEX_STRING(cleanHex));\n  }\n  const out = new Uint8Array(cleanHex.length / 2);\n  for (let i = 0; i < cleanHex.length; i += 2) {\n    out[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);\n  }\n  return out;\n}\n\n/**\n * Encodes bytes as a lowercase hex string (no `0x` prefix).\n *\n * Accepts either an `ArrayBuffer` or `Uint8Array`.\n */\nexport function toHex(buffer: ArrayBuffer | Uint8Array): string {\n  const uint8Array =\n    buffer instanceof ArrayBuffer ? new Uint8Array(buffer) : buffer;\n  return Array.from(uint8Array)\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n\n/**\n * Normalizes a hex string to a canonical form.\n *\n * - Strips optional `0x` prefix and whitespace\n * - Pads a leading `0` if the length is odd\n * - Validates by round-tripping through `fromHex`/`toHex`\n * - Returns lowercase hex with optional `0x` prefix when `with0x === true`\n */\nexport function normalizeHex(input: string, with0x = true): string {\n  const cleaned = input.replace(/^0x/i, \"\").replace(/\\s/g, \"\");\n  const padded = cleaned.length % 2 === 1 ? `0${cleaned}` : cleaned;\n  const bytes = fromHex(padded);\n  const hex = toHex(bytes);\n  return with0x ? `0x${hex}` : hex;\n}\n\n/**\n * Decodes a base64 string into bytes.\n *\n * - Uses `atob` in browser environments when available\n * - Falls back to `Buffer.from(..., 'base64')` in Node\n * - Throws `ERROR_NO_BASE64_DECODER` if no decoder is available\n */\nexport function fromBase64(base64: string): Uint8Array {\n  const clean = base64.replace(/\\s/g, \"\");\n  // Browser: use atob when available\n  if (typeof globalThis.atob === \"function\") {\n    const binaryString = globalThis.atob(clean);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n  // Node: use Buffer when available without forcing bundler polyfills\n  const NodeBuffer = (\n    globalThis as unknown as {\n      Buffer?: typeof Buffer;\n    }\n  ).Buffer;\n  if (NodeBuffer && typeof NodeBuffer.from === \"function\") {\n    return new Uint8Array(NodeBuffer.from(clean, \"base64\"));\n  }\n  throw new Error(ERROR_NO_BASE64_DECODER);\n}\n","import { SIGNING_ALGORITHM_CONFIG } from \"./algorithms.js\";\nimport { ERROR_ALGORITHM_NOT_SUPPORTED } from \"./constants/errors.js\";\nimport { normalizeHex } from \"./utils/hex.js\";\nexport type PublicKey = {\n  key: string; // hex string\n  algorithm: keyof typeof SIGNING_ALGORITHM_CONFIG;\n};\n\nexport function generate(...publicKeys: PublicKey[]): string {\n  const pubKeys: object[] = publicKeys.map((publicKey, index) => {\n    if (\n      !Object.prototype.hasOwnProperty.call(\n        SIGNING_ALGORITHM_CONFIG,\n        publicKey.algorithm\n      )\n    ) {\n      throw new Error(ERROR_ALGORITHM_NOT_SUPPORTED(publicKey.algorithm));\n    }\n\n    return {\n      // EIP states 1-indexed string\n      id: (index + 1).toString(),\n      alg: publicKey.algorithm,\n      publicKey: normalizeHex(publicKey.key),\n    };\n  });\n\n  return JSON.stringify({\n    publicKeys: pubKeys,\n  });\n}\n","import { webcrypto as nodeWebcrypto } from \"crypto\";\n\nfunction resolveWebcrypto(): Crypto {\n  if (globalThis.crypto?.subtle) return globalThis.crypto;\n  return nodeWebcrypto as unknown as Crypto;\n}\n\nexport const webcrypto = resolveWebcrypto();\n","export type JsonPrimitive = null | boolean | number | string;\nexport type JsonValue =\n  | JsonPrimitive\n  | JsonValue[]\n  | { [key: string]: JsonValue };\n\nexport type RequestPayload<Params = Record<string, unknown>> = {\n  method: string;\n  params: Params;\n};\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    Object.getPrototypeOf(value) === Object.prototype\n  );\n}\n\n/**\n * Canonicalizes a JSON-like value to enable deterministic serialization.\n *\n * - Sorts object keys lexicographically\n * - Drops properties with undefined values\n * - Recursively processes objects and arrays (preserving array order)\n * - Leaves primitives and non-plain objects unchanged\n *\n * Used by `canonicalStringify` and `serializeRequestPayload` to produce stable\n * byte sequences for cryptographic signing and verification.\n */\nfunction canonicalize(value: unknown): unknown {\n  if (Array.isArray(value)) {\n    return value.map((item) => canonicalize(item));\n  }\n\n  if (isPlainObject(value)) {\n    const sortedKeys = Object.keys(value).sort();\n    const result: Record<string, unknown> = {};\n    for (const key of sortedKeys) {\n      const v = value[key];\n      if (v === undefined) continue; // drop undefined values\n      result[key] = canonicalize(v);\n    }\n    return result;\n  }\n\n  // For primitives (including null) and non-plain objects, return as-is\n  return value;\n}\n\nexport function canonicalStringify(value: unknown): string {\n  return JSON.stringify(canonicalize(value));\n}\n\nexport function serializeRequestPayload<T>(requestPayload: T): Uint8Array {\n  return new TextEncoder().encode(canonicalStringify(requestPayload));\n}\n","import { webcrypto } from \"./utils/webcrypto.js\";\nimport {\n  SIGNING_ALGORITHM_CONFIG,\n  SIGNING_ALGORITHM_IMPORT_PARAMS,\n} from \"./algorithms.js\";\nimport { toHex, fromHex } from \"./utils/hex.js\";\nimport { serializeRequestPayload } from \"./utils/canonicalJson.js\";\nimport { ERROR_ALGORITHM_NOT_SUPPORTED } from \"./constants/errors.js\";\n\nconst encoder = new TextEncoder();\nconst PRIVATE_KEY_FORMAT = \"pkcs8\";\n\nexport async function sign(\n  data: string | object,\n  privateKey: string,\n  algorithm: keyof typeof SIGNING_ALGORITHM_CONFIG\n): Promise<string> {\n  if (\n    typeof algorithm !== \"string\" ||\n    !Object.prototype.hasOwnProperty.call(SIGNING_ALGORITHM_CONFIG, algorithm)\n  ) {\n    throw new Error(ERROR_ALGORITHM_NOT_SUPPORTED(algorithm));\n  }\n\n  const bufferData =\n    typeof data === \"string\"\n      ? encoder.encode(data)\n      : serializeRequestPayload(data);\n\n  const key = await webcrypto.subtle.importKey(\n    PRIVATE_KEY_FORMAT,\n    fromHex(privateKey) as BufferSource,\n    SIGNING_ALGORITHM_IMPORT_PARAMS[algorithm],\n    false,\n    [\"sign\"]\n  );\n\n  const signature = await webcrypto.subtle.sign(\n    SIGNING_ALGORITHM_CONFIG[algorithm],\n    key,\n    bufferData as BufferSource\n  );\n\n  return `0x${toHex(signature)}`;\n}\n","import { ERROR_INVALID_TXT_RECORD_FORMAT } from \"../constants/errors.js\";\n\n/**\n * Decodes DNS TXT record wire-format bytes (RFC 1035) into a UTF-8 string.\n *\n * TXT RDATA is a sequence of length-prefixed character strings. This function\n * iterates the chunks, validates boundaries, decodes each as UTF-8, and\n * concatenates them. Throws `ERROR_INVALID_TXT_RECORD_FORMAT` if the data is\n * truncated or malformed.\n */\nexport function parseTxtRecord(buffer: ArrayBuffer | Uint8Array): string {\n  const view = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  const decoder = new TextDecoder();\n  let result = \"\";\n  let offset = 0;\n\n  while (offset < view.length) {\n    const length = view[offset];\n    offset += 1;\n\n    if (offset + length > view.length) {\n      throw new Error(ERROR_INVALID_TXT_RECORD_FORMAT);\n    }\n\n    const slice = view.subarray(offset, offset + length);\n    result += decoder.decode(slice);\n    offset += length;\n  }\n\n  return result;\n}\n\n/**\n * Normalizes DNS TXT record data into a string.\n *\n * - If `data` is a string, returns it as-is\n * - If `data` is a Uint8Array or ArrayBuffer, decodes RFC length-prefixed TXT chunks via `parseTxtRecord`\n * - Otherwise, returns a best-effort string cast\n *\n * Used by verification code that consumes DoH responses where TXT answers may\n * be provided either as raw wire-format bytes or plain strings.\n */\nexport function processTxtRecordData(data: unknown): string {\n  if (typeof data === \"string\") {\n    return data;\n  }\n  if (data instanceof Uint8Array || data instanceof ArrayBuffer) {\n    return parseTxtRecord(data);\n  }\n  // Fallback for other types\n  return String(data);\n}\n","import { webcrypto } from \"./utils/webcrypto.js\";\nimport {\n  SigningAlgorithmConfig,\n  SIGNING_ALGORITHM_CONFIG,\n  SIGNING_ALGORITHM_IMPORT_PARAMS,\n} from \"./algorithms.js\";\nimport {\n  ERROR_ALGORITHM_NOT_SUPPORTED,\n  ERROR_MANIFEST_CONTENT_TYPE,\n  ERROR_MANIFEST_FETCH_FAILED,\n  ERROR_MANIFEST_HTTPS_ONLY,\n  ERROR_MANIFEST_TOO_LARGE,\n  ERROR_MULTIPLE_PUBLIC_KEYS_WITH_ID,\n  ERROR_MULTIPLE_TXT_WITH_PREFIX_FOR_HOST,\n  ERROR_NO_TXT_RECORDS_FOR_HOST,\n  ERROR_NO_TXT_WITH_PREFIX_FOR_HOST,\n  ERROR_PUBLIC_KEY_ID_NOT_FOUND,\n  ERROR_TWIST_PATH_TOO_LONG,\n} from \"./constants/errors.js\";\nimport { fromHex } from \"./utils/hex.js\";\nimport { processTxtRecordData } from \"./utils/txtRecord.js\";\nimport dohjs from \"dohjs\";\n\nconst { DohResolver } = dohjs;\nexport const PREFIX = \"TWIST=\";\nconst quadOneResolver = new DohResolver(\"https://1.1.1.1/dns-query\");\nconst TIMEOUT = 1000;\nconst MAX_MANIFEST_BYTES = 64 * 1024; // 64KB\nconst MAX_TWIST_PATH = 1024;\nconst PUBLIC_KEY_FORMAT = \"spki\";\n\nexport async function verifyAsyncDns(\n  calldata: string,\n  signature: string,\n  host: string,\n  id: string,\n  thisResolver: InstanceType<typeof DohResolver> = quadOneResolver\n): Promise<boolean> {\n  // Use DNS over HTTPS to resolve TXT records\n  const response = await thisResolver.query(\n    host,\n    \"TXT\",\n    \"GET\",\n    {\n      Accept: \"application/dns-message\",\n    },\n    TIMEOUT\n  );\n\n  if (!response.answers || response.answers.length === 0) {\n    throw new Error(ERROR_NO_TXT_RECORDS_FOR_HOST(host));\n  }\n\n  let twistRecord: string | undefined;\n\n  // Scan all TXT records; capture the first with PREFIX and throw if another is found\n  for (const answer of response.answers) {\n    const recordData = processTxtRecordData(answer.data);\n\n    if (recordData.startsWith(PREFIX)) {\n      if (twistRecord) {\n        throw new Error(ERROR_MULTIPLE_TXT_WITH_PREFIX_FOR_HOST(PREFIX, host));\n      } else {\n        twistRecord = recordData.slice(PREFIX.length);\n      }\n    }\n  }\n\n  if (!twistRecord) {\n    throw new Error(ERROR_NO_TXT_WITH_PREFIX_FOR_HOST(PREFIX, host));\n  }\n\n  // Normalize and bound TWIST path; encode path segments\n  twistRecord = twistRecord.replace(/^\\/+/, \"\");\n  if (twistRecord.length > MAX_TWIST_PATH) {\n    throw new Error(ERROR_TWIST_PATH_TOO_LONG);\n  }\n  const encodedPath = twistRecord\n    .split(\"/\")\n    .map((segment) => encodeURIComponent(segment))\n    .join(\"/\");\n\n  const url = new URL(`https://${host}/${encodedPath}`);\n\n  return await verifyAsyncJson(calldata, signature, url, id);\n}\n\nexport async function verifyAsyncJson(\n  calldata: string,\n  signature: string,\n  url: URL,\n  id: string\n): Promise<boolean> {\n  if (url.protocol !== \"https:\") {\n    throw new Error(ERROR_MANIFEST_HTTPS_ONLY);\n  }\n\n  const controller = new AbortController();\n  const timer = setTimeout(() => controller.abort(), TIMEOUT);\n  let response: Response;\n  try {\n    response = await fetch(url, {\n      redirect: \"error\",\n      signal: controller.signal,\n      headers: { Accept: \"application/json\" },\n    });\n  } finally {\n    clearTimeout(timer);\n  }\n\n  if (!response.ok) {\n    throw new Error(ERROR_MANIFEST_FETCH_FAILED(response.status));\n  }\n\n  const ct = response.headers.get(\"content-type\") || \"\";\n  if (!/^application\\/json(?:;|$)/i.test(ct)) {\n    throw new Error(ERROR_MANIFEST_CONTENT_TYPE);\n  }\n\n  const cl = response.headers.get(\"content-length\");\n  if (cl && Number(cl) > MAX_MANIFEST_BYTES) {\n    throw new Error(ERROR_MANIFEST_TOO_LARGE);\n  }\n\n  const data = (await response.json()) as {\n    publicKeys: Array<{\n      id: string;\n      alg: string;\n      publicKey: string;\n    }>;\n  };\n  const matchingKeys = data.publicKeys.filter((pk) => pk.id === id.toString());\n\n  if (matchingKeys.length === 0) {\n    throw new Error(ERROR_PUBLIC_KEY_ID_NOT_FOUND(id));\n  }\n\n  if (matchingKeys.length > 1) {\n    throw new Error(ERROR_MULTIPLE_PUBLIC_KEYS_WITH_ID(id));\n  }\n\n  const publicKey = matchingKeys[0];\n\n  if (\n    !Object.prototype.hasOwnProperty.call(\n      SIGNING_ALGORITHM_IMPORT_PARAMS,\n      publicKey.alg\n    )\n  ) {\n    throw new Error(ERROR_ALGORITHM_NOT_SUPPORTED(publicKey.alg));\n  }\n  const algorithmKey =\n    publicKey.alg as keyof typeof SIGNING_ALGORITHM_IMPORT_PARAMS;\n\n  const publicKeyObject = await webcrypto.subtle.importKey(\n    PUBLIC_KEY_FORMAT,\n    fromHex(publicKey.publicKey) as BufferSource,\n    SIGNING_ALGORITHM_IMPORT_PARAMS[algorithmKey],\n    false,\n    [\"verify\"]\n  );\n\n  return await verify(calldata, signature, publicKeyObject, algorithmKey);\n}\n\nexport async function verify(\n  calldata: string,\n  signature: string,\n  publicKey: CryptoKey,\n  alg: keyof typeof SIGNING_ALGORITHM_CONFIG\n): Promise<boolean> {\n  const bufferData = new TextEncoder().encode(calldata);\n\n  const signatureBytes = fromHex(signature);\n\n  if (!Object.prototype.hasOwnProperty.call(SIGNING_ALGORITHM_CONFIG, alg)) {\n    throw new Error(ERROR_ALGORITHM_NOT_SUPPORTED(alg));\n  }\n  const algConfig: SigningAlgorithmConfig = SIGNING_ALGORITHM_CONFIG[alg];\n\n  // Use algorithm params directly from configuration\n  const verifyParams = algConfig as unknown as\n    | Algorithm\n    | EcdsaParams\n    | RsaPssParams;\n\n  let signatureForVerify: Uint8Array = signatureBytes;\n  if (algConfig.name === \"ECDSA\") {\n    // Only accept raw r||s for ECDSA signatures and pass raw to verify\n    const coordLen = algConfig.ecdsaCoordinateLength;\n    if (!coordLen) {\n      throw new Error(\"ECDSA algorithm missing ecdsaCoordinateLength\");\n    }\n    if (signatureBytes.length !== coordLen * 2) {\n      return false;\n    }\n    signatureForVerify = signatureBytes;\n  }\n\n  const verified = await webcrypto.subtle.verify(\n    verifyParams,\n    publicKey,\n    signatureForVerify as BufferSource,\n    bufferData as BufferSource\n  );\n  return verified;\n}\n"]}